if (currentBuild.getBuildCauses().toString().contains('BranchIndexingCause')) {
  print "INFO: Build skipped due to trigger being Branch Indexing"
  currentBuild.result = 'ABORTED' // optional, gives a better hint to the user that it's been skipped, rather than the default which shows it's successful
  return
}

pipeline {
    agent {
       kubernetes {
         //cloud 'kubernetes'
         label 'pinp'
         yaml """
             apiVersion: v1
             kind: Pod
             spec:
               imagePullSecrets:
               - name: yinhe-reg
               containers:
               - name: jnlp
                 image: reg.yhroot.com/yinhe-pub/jnlp-slave:3.27-1
               - name: pinp
                 image: reg.yhroot.com/yinhe-pub/kubectl:latest
                 imagePullPolicy: Always
                 securityContext:
                   privileged: true
                 tty: true
           """
       }
    }
    parameters {
        string(name:'APP_NAME', defaultValue: '', description:'项目名')
        string(name:'APP_REPO', defaultValue: '', description:'项目仓库地址')
        choice(description: "执行动作", name: "DFLAG",choices: ['只编译镜像','部署镜像'])
        choice(description: "选择pipline模板", name: "PIPE_TEMP",choices: ['nodejs','python'])
        choice(description: "选择部署环境", name: "DEPLOY_ENV", choices: ['test','beta','prod'])
    }
    environment {
        GITLAB_KEY = 'git-ssh'
        KUBECONFIG_CREDENTIAL_ID = 'kubeconf'
        REGISTRY = 'reg.yhroot.com'
        CICD_BRANCH = 'test'
        PIPE_NAME = 'pinp'
    }

    stages {
        stage ('checkout cicd repo') {
            steps {
                dir("${PIPE_NAME}/cicd-repo") {
                  git credentialsId: "${GITLAB_KEY}", branch: "$BRANCH_NAME", url: 'git@github.com:dxzxomy/cicd.git'
                }
            }
        }

        stage ('build pipeline') {
            steps {
                container ('pinp') {
                  dir("${PIPE_NAME}/pinp-repo") {
                        script {
                            sh 'ls'
                            sh "kubectl -f apply ./pipeline.yaml"

                        }
                   }
                }
            }
        }

       stage('get app and deploy conf') {
           steps {
                dir("$APP_NAME/config-repo") {
                   sh 'ls -alh . && pwd'
                   sh "cp -ra $APP_NAME/config/${DEPLOY_ENV} ../$APP_NAME/apps_config"
                }
           }
       }
        stage('docker build & push') {
            steps {
                container ('dind') {
                  dir("${APP_NAME}/$APP_NAME") {
                     script {
                         sh "cp ../cicd-repo/$APP_NAME/test/Dockerfile-test Dockerfile-now"
                         docker.withRegistry("https://$REGISTRY", 'harbor') {
                             def customImage = docker.build("satop/$APP_NAME:${SCM_TAG}-${DEPLOY_ENV}-$BUILD_NUMBER","--build-arg GIT_TAG=${SCM_TAG} --build-arg GIT_COMMIT=${GIT_COMMIT} --build-arg appname=${APP_NAME} --build-arg dpenv=${DEPLOY_ENV} --no-cache -f ./Dockerfile-now .")
                             customImage.push()
                        }
                     }
                  }
                }
                echo "生成的镜像地址：$REGISTRY/satop/$APP_NAME:${SCM_TAG}-${DEPLOY_ENV}-$BUILD_NUMBER"

            }
        }
       stage('deploy to production') {
             when{
               expression{
                 return params.DFLAG =~ /部署镜像/
               }
             }
             steps {
               input(id: 'deploy-to-production', message: 'deploy to production?')
               dir("$APP_NAME/config-repo") {
                   sh "ls -alh ./$APP_NAME/deploy/${DEPLOY_ENV}/"
                   kubernetesDeploy(configs: "$APP_NAME/deploy/${DEPLOY_ENV}/**", enableConfigSubstitution: true, kubeconfigId: "$KUBECONFIG_CREDENTIAL_ID")
               }
             }
        }
  }
}
